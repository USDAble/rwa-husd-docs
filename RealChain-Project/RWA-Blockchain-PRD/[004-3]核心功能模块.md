# USDable Chain 开发需求文档 - 第 3 章: 核心功能模块

**文档编号**: [004-3]  
**文档版本**: v2.0  
**创建时间**: 2025-10-15 13:32 CST  
**更新时间**: 2025-10-15 15:45 CST  
**文档类型**: Product Requirements Document (PRD)  
**所属项目**: USDable Chain 全栈公链开发  

---

## 模块概览

本章详细描述 USDable Chain 的 7 个核心功能模块的设计和实现:

1. **RWA Registry** (资产存证模块)
2. **Compliance Guard** (合规模块)
3. **Oracle Hub** (预言机中心)
4. **Escrow Vault** (抵押与保险池)
5. **Distributor** (分红系统)
6. **Liquidation Engine** (清算引擎)
7. **FeePool** (费用池)

---

## 3.1 RWA Registry (资产存证模块)

### 3.1.1 模块概述

**核心职责**: 存证产权、评估报告、合同文件哈希,生成唯一 HRWA-ID,发行 XRWA 标准代币

**核心功能**:

-   ✅ 资产上链 (Asset Onboarding): 房东上传产权证明、评估报告、租赁合同
-   ✅ HRWA-ID 生成: 每个资产生成唯一的 HRWA-ID (Hash-based RWA ID)
-   ✅ XRWA 代币发行: 基于 ERC-3643 扩展的 XRWA 标准代币
-   ✅ 元数据管理: 存储资产元数据 (产权、估值、租金、位置等)
-   ✅ 文档哈希存证: 存储产权证明、评估报告、合同文件的哈希值

### 3.1.2 核心合约

#### RWARegistry (资产注册表)

**职责**: 创建和管理资产,生成 HRWA-ID,发行 XRWA 代币

**核心接口**:

```solidity
interface IRWARegistry {
    // 创建资产并生成HRWA-ID
    function createAsset(
        AssetInfo memory info,
        DocumentHashes memory docs
    ) external returns (bytes32 hrwaId, address xrwaToken);

    // 获取资产信息
    function getAsset(bytes32 hrwaId) external view returns (AssetInfo memory);

    // 获取XRWA代币地址
    function getXRWAToken(bytes32 hrwaId) external view returns (address);

    // 更新资产估值
    function updateValuation(bytes32 hrwaId, uint256 newValuation) external;
}

struct AssetInfo {
    string assetType;        // 资产类型: "RealEstate", "Vehicle", "Art", etc.
    string location;         // 资产位置 (城市、地址)
    uint256 valuation;       // 资产估值 (USD)
    uint256 totalSupply;     // 代币总供应量
    uint256 rentalYield;     // 年化租金收益率 (basis points, e.g., 500 = 5%)
    address landlord;        // 房东地址
    uint256 createdAt;       // 创建时间
}

struct DocumentHashes {
    bytes32 propertyDeedHash;    // 产权证明哈希
    bytes32 valuationReportHash; // 评估报告哈希
    bytes32 leaseContractHash;   // 租赁合同哈希
}
```

**实现示例**:

```solidity
contract RWARegistry is IRWARegistry {
    mapping(bytes32 => AssetInfo) public assets;
    mapping(bytes32 => address) public xrwaTokens;
    mapping(bytes32 => DocumentHashes) public documents;

    event AssetCreated(
        bytes32 indexed hrwaId,
        address indexed xrwaToken,
        address indexed landlord,
        string assetType,
        uint256 valuation
    );

    function createAsset(
        AssetInfo memory info,
        DocumentHashes memory docs
    ) external override returns (bytes32 hrwaId, address xrwaToken) {
        // 1. 验证房东权限 (通过Compliance Guard)
        require(
            complianceGuard.isVerified(msg.sender),
            "Landlord not verified"
        );

        // 2. 生成HRWA-ID (使用预编译合约0x0C)
        hrwaId = _generateHRWAID(info, docs);

        // 3. 部署XRWA代币合约
        xrwaToken = address(new XRWAToken(
            string(abi.encodePacked("XRWA-", info.assetType)),
            "XRWA",
            info.totalSupply,
            hrwaId,
            msg.sender
        ));

        // 4. 记录资产
        assets[hrwaId] = info;
        xrwaTokens[hrwaId] = xrwaToken;
        documents[hrwaId] = docs;

        // 5. 触发事件
        emit AssetCreated(hrwaId, xrwaToken, msg.sender, info.assetType, info.valuation);

        return (hrwaId, xrwaToken);
    }

    function _generateHRWAID(
        AssetInfo memory info,
        DocumentHashes memory docs
    ) internal view returns (bytes32) {
        // 调用预编译合约0x0C生成HRWA-ID
        return keccak256(abi.encodePacked(
            info.assetType,
            info.location,
            docs.propertyDeedHash,
            block.timestamp,
            msg.sender
        ));
    }

    function getAsset(bytes32 hrwaId) external view override returns (AssetInfo memory) {
        return assets[hrwaId];
    }

    function getXRWAToken(bytes32 hrwaId) external view override returns (address) {
        return xrwaTokens[hrwaId];
    }

    function updateValuation(bytes32 hrwaId, uint256 newValuation) external override {
        require(assets[hrwaId].landlord == msg.sender, "Not landlord");
        assets[hrwaId].valuation = newValuation;
    }
}
```

#### XRWAToken (XRWA 标准代币)

**职责**: 基于 ERC-3643 扩展的 XRWA 标准代币,支持合规转账

**核心接口**:

```solidity
interface IXRWAToken is IERC20 {
    // 获取HRWA-ID
    function getHRWAID() external view returns (bytes32);

    // 获取资产元数据
    function getAssetInfo() external view returns (AssetInfo memory);

    // 合规转账 (需通过Compliance Guard检查)
    function transfer(address to, uint256 amount) external returns (bool);

    // 获取历史估值
    function getValuationHistory() external view returns (ValuationRecord[] memory);
}

struct ValuationRecord {
    uint256 valuation;
    uint256 timestamp;
    address oracle;
}
```

**实现示例**:

```solidity
contract AssetToken is ERC20, IAssetToken {
    AssetMetadata public metadata;
    ValuationRecord[] public valuationHistory;

    constructor(
        string memory name,
        string memory symbol,
        uint256 totalSupply,
        AssetMetadata memory _metadata,
        address issuer
    ) ERC20(name, symbol) {
        metadata = _metadata;
        _mint(issuer, totalSupply);

        // 记录初始估值
        valuationHistory.push(ValuationRecord({
            valuation: _metadata.valuation,
            timestamp: block.timestamp,
            oracle: address(0)
        }));
    }

    function getMetadata() external view override returns (AssetMetadata memory) {
        return metadata;
    }

    function updateValuation(uint256 newValuation) external override {
        // 只有授权的预言机可以更新估值
        require(
            oracleRegistry.isAuthorized(msg.sender),
            "Not authorized oracle"
        );

        metadata.valuation = newValuation;

        valuationHistory.push(ValuationRecord({
            valuation: newValuation,
            timestamp: block.timestamp,
            oracle: msg.sender
        }));

        emit ValuationUpdated(newValuation, msg.sender);
    }

    function getCurrentValuation() external view override returns (uint256) {
        return metadata.valuation;
    }

    function getValuationHistory() external view override returns (ValuationRecord[] memory) {
        return valuationHistory;
    }
}
```

### 3.1.3 业务流程

#### 资产代币化流程

```mermaid
sequenceDiagram
    participant Issuer as 资产发行方
    participant KYC as KYC/AML模块
    participant Factory as AssetFactory
    participant Token as AssetToken
    participant Oracle as 估值预言机

    Issuer->>KYC: 1. 提交KYC/AML资料
    KYC-->>Issuer: 2. KYC验证通过

    Issuer->>Factory: 3. 创建资产代币
    Note over Factory: 验证发行方权限
    Factory->>Token: 4. 部署AssetToken合约
    Token-->>Factory: 5. 返回代币地址
    Factory-->>Issuer: 6. 返回代币地址

    Oracle->>Token: 7. 更新资产估值
    Token-->>Oracle: 8. 估值更新成功

    Note over Issuer,Oracle: 资产代币化完成
```

### 3.1.4 验收标准

✅ **功能验收**:

-   支持至少 5 种资产类型 (房地产、艺术品、碳信用、私募信贷、其他)
-   7 天内完成资产代币化
-   支持元数据更新和版本控制

✅ **性能验收**:

-   创建资产代币: <10 秒
-   查询资产元数据: <1 秒
-   更新资产估值: <5 秒

✅ **安全验收**:

-   通过 3+次独立安全审计
-   只有授权预言机可以更新估值
-   元数据不可篡改 (使用 IPFS 存储)

---

## 3.2 Compliance Guard (合规模块)

### 3.2.1 模块概述

**核心职责**: 执行 KYC/AML、审核资产合法性、白名单/地域限制/风险分级、SBT 身份凭证

**核心功能**:

-   ✅ KYC/AML 验证: 对接 Sumsub、Chainalysis 等第三方 KYC 提供商
-   ✅ SBT 身份凭证: 发行不可转让的 Soul Bound Token (SBT) 作为身份凭证
-   ✅ 白名单管理: 管理合格投资者白名单
-   ✅ 地域限制: 限制特定国家/地区的投资者
-   ✅ 风险分级: 根据投资者 KYC 等级进行风险分级
-   ✅ 转账前合规检查: 每次转账前检查发送方和接收方的合规状态
-   ✅ 资产冻结: 监管要求下冻结资产

### 3.2.2 核心合约

#### IdentityRegistry (身份注册表)

**职责**: 管理用户身份和 KYC 状态

**核心接口**:

```solidity
interface IIdentityRegistry {
    // 注册身份
    function registerIdentity(
        address investor,
        uint256 kycLevel,
        uint256 country,
        bytes32 identityHash
    ) external;

    // 验证身份
    function isVerified(address investor) external view returns (bool);

    // 获取身份信息
    function getIdentity(address investor) external view returns (Identity memory);

    // 撤销身份
    function revokeIdentity(address investor) external;
}

struct Identity {
    bool verified;
    uint256 kycLevel;      // 1: Basic, 2: Advanced, 3: Institutional
    uint256 country;       // 国家代码 (ISO 3166-1)
    bytes32 identityHash;  // 身份哈希 (隐私保护)
    uint256 expiryDate;    // KYC过期时间
    address kycProvider;   // KYC提供商
}
```

**实现示例**:

```solidity
contract IdentityRegistry is IIdentityRegistry {
    mapping(address => Identity) public identities;
    mapping(address => bool) public kycProviders;

    event IdentityRegistered(
        address indexed investor,
        uint256 kycLevel,
        uint256 country
    );

    event IdentityRevoked(address indexed investor);

    modifier onlyKYCProvider() {
        require(kycProviders[msg.sender], "Not a KYC provider");
        _;
    }

    function registerIdentity(
        address investor,
        uint256 kycLevel,
        uint256 country,
        bytes32 identityHash
    ) external override onlyKYCProvider {
        require(kycLevel >= 1 && kycLevel <= 3, "Invalid KYC level");

        identities[investor] = Identity({
            verified: true,
            kycLevel: kycLevel,
            country: country,
            identityHash: identityHash,
            expiryDate: block.timestamp + 365 days,
            kycProvider: msg.sender
        });

        emit IdentityRegistered(investor, kycLevel, country);
    }

    function isVerified(address investor) external view override returns (bool) {
        Identity memory identity = identities[investor];
        return identity.verified && identity.expiryDate > block.timestamp;
    }

    function getIdentity(address investor) external view override returns (Identity memory) {
        return identities[investor];
    }

    function revokeIdentity(address investor) external override onlyKYCProvider {
        identities[investor].verified = false;
        emit IdentityRevoked(investor);
    }
}
```

#### ComplianceModule (合规模块)

**职责**: 转账前合规检查

**核心接口**:

```solidity
interface IComplianceModule {
    // 转账前检查
    function canTransfer(
        address from,
        address to,
        uint256 amount
    ) external view returns (bool, string memory);

    // 强制转账 (监管要求)
    function forcedTransfer(
        address token,
        address from,
        address to,
        uint256 amount
    ) external;

    // 冻结资产
    function freezeAsset(address token, address investor) external;

    // 解冻资产
    function unfreezeAsset(address token, address investor) external;
}
```

**实现示例**:

```solidity
contract ComplianceModule is IComplianceModule {
    IIdentityRegistry public identityRegistry;

    mapping(address => mapping(address => bool)) public frozenAssets;
    mapping(uint256 => bool) public blockedCountries;
    mapping(address => uint256) public maxHoldings;

    function canTransfer(
        address from,
        address to,
        uint256 amount
    ) external view override returns (bool, string memory) {
        // 1. 检查发送方和接收方的KYC状态
        if (!identityRegistry.isVerified(from)) {
            return (false, "Sender not verified");
        }
        if (!identityRegistry.isVerified(to)) {
            return (false, "Receiver not verified");
        }

        // 2. 检查资产是否被冻结
        if (frozenAssets[msg.sender][from]) {
            return (false, "Sender assets frozen");
        }
        if (frozenAssets[msg.sender][to]) {
            return (false, "Receiver assets frozen");
        }

        // 3. 检查国家限制
        Identity memory toIdentity = identityRegistry.getIdentity(to);
        if (blockedCountries[toIdentity.country]) {
            return (false, "Country blocked");
        }

        // 4. 检查持有量限制
        uint256 maxHolding = maxHoldings[msg.sender];
        if (maxHolding > 0) {
            uint256 currentBalance = IERC20(msg.sender).balanceOf(to);
            if (currentBalance + amount > maxHolding) {
                return (false, "Exceeds max holding");
            }
        }

        return (true, "");
    }

    function forcedTransfer(
        address token,
        address from,
        address to,
        uint256 amount
    ) external override onlyRegulator {
        // 监管机构可以强制转账
        IAssetToken(token).transferFrom(from, to, amount);

        emit ForcedTransfer(token, from, to, amount, msg.sender);
    }

    function freezeAsset(address token, address investor) external override onlyRegulator {
        frozenAssets[token][investor] = true;
        emit AssetFrozen(token, investor);
    }

    function unfreezeAsset(address token, address investor) external override onlyRegulator {
        frozenAssets[token][investor] = false;
        emit AssetUnfrozen(token, investor);
    }
}
```

### 3.2.3 业务流程

#### KYC/AML 验证流程

```mermaid
sequenceDiagram
    participant User as 用户
    participant KYC as KYC提供商
    participant Registry as IdentityRegistry
    participant Compliance as ComplianceModule

    User->>KYC: 1. 提交KYC资料
    KYC->>KYC: 2. 验证身份信息
    KYC->>Registry: 3. 注册身份
    Registry-->>KYC: 4. 注册成功
    KYC-->>User: 5. KYC验证通过

    User->>Compliance: 6. 尝试转账
    Compliance->>Registry: 7. 检查KYC状态
    Registry-->>Compliance: 8. 返回KYC状态
    Compliance-->>User: 9. 转账成功/失败
```

### 3.2.4 验收标准

✅ **功能验收**:

-   支持 3 级 KYC (Basic, Advanced, Institutional)
-   支持至少 10 个国家/地区的合规要求
-   支持强制转账和资产冻结

✅ **性能验收**:

-   KYC 验证: <5 秒
-   转账前合规检查: <1 秒
-   强制转账: <10 秒

✅ **安全验收**:

-   通过 3+次独立安全审计
-   身份数据加密存储
-   只有授权的 KYC 提供商可以注册身份

---

## 3.3 Oracle Hub (预言机中心)

### 3.3.1 模块概述

**核心职责**: 多源数据验证 (Chainlink + 自建 + DePIN),提供资产估值、租金数据、市场数据

**核心功能**:

-   ✅ Chainlink 预言机: 对接 Chainlink 获取市场数据 (房价指数、利率等)
-   ✅ 自建预言机: 自建预言机网络,由服务节点提供数据
-   ✅ DePIN 数据: 对接 DePIN (Decentralized Physical Infrastructure Network) 获取物理世界数据
-   ✅ 多数据源验证: 至少 3 个数据源确认后才接受数据
-   ✅ 数据质押和奖励: 服务节点质押 3,000 ABLE,提供准确数据获得奖励
-   ✅ Slash 惩罚: 提供虚假数据的服务节点将被 Slash 20%质押

### 3.3.2 核心合约

#### DataVerifier (数据验证器)

**职责**: 验证真实世界数据的准确性

**核心接口**:

```solidity
interface IDataVerifier {
    // 提交数据验证请求
    function submitDataProof(
        bytes32 dataHash,
        bytes memory zkProof,
        string memory dataSource
    ) external;

    // 验证数据
    function verifyData(bytes32 dataHash) external view returns (bool);

    // 获取数据验证记录
    function getDataProof(bytes32 dataHash) external view returns (DataProof memory);
}

struct DataProof {
    bytes32 dataHash;
    bytes zkProof;
    address[] providers;
    uint256 confirmations;
    bool verified;
    uint256 timestamp;
}
```

**实现示例**:

```solidity
contract DataVerifier is IDataVerifier {
    mapping(bytes32 => DataProof) public dataProofs;
    mapping(address => bool) public authorizedProviders;

    uint256 public constant MIN_CONFIRMATIONS = 3;
    uint256 public constant VERIFICATION_REWARD = 1 ether;

    event DataProofSubmitted(
        bytes32 indexed dataHash,
        address indexed provider,
        uint256 confirmations
    );

    event DataVerified(
        bytes32 indexed dataHash,
        uint256 confirmations,
        uint256 timestamp
    );

    function submitDataProof(
        bytes32 dataHash,
        bytes memory zkProof,
        string memory dataSource
    ) external override {
        require(authorizedProviders[msg.sender], "Not authorized provider");

        DataProof storage proof = dataProofs[dataHash];

        // 首次提交
        if (proof.confirmations == 0) {
            proof.dataHash = dataHash;
            proof.zkProof = zkProof;
            proof.timestamp = block.timestamp;
        }

        // 验证zkTLS证明
        require(verifyZkTLSProof(zkProof, dataHash), "Invalid zkTLS proof");

        // 记录确认
        proof.providers.push(msg.sender);
        proof.confirmations++;

        emit DataProofSubmitted(dataHash, msg.sender, proof.confirmations);

        // 达到最小确认数
        if (proof.confirmations >= MIN_CONFIRMATIONS) {
            proof.verified = true;

            // 分发奖励
            for (uint i = 0; i < proof.providers.length; i++) {
                payable(proof.providers[i]).transfer(VERIFICATION_REWARD);
            }

            emit DataVerified(dataHash, proof.confirmations, block.timestamp);
        }
    }

    function verifyData(bytes32 dataHash) external view override returns (bool) {
        return dataProofs[dataHash].verified;
    }

    function getDataProof(bytes32 dataHash) external view override returns (DataProof memory) {
        return dataProofs[dataHash];
    }

    // 验证zkTLS证明 (简化版)
    function verifyZkTLSProof(bytes memory zkProof, bytes32 dataHash) internal pure returns (bool) {
        // 实际实现需要使用zkTLS库
        // 这里仅作示例
        return keccak256(zkProof) != bytes32(0);
    }
}
```

### 3.3.3 验收标准

✅ **功能验收**:

-   支持 zkTLS 数据验证
-   至少 3 个独立数据源确认
-   支持数据提供者质押和奖励

✅ **性能验收**:

-   数据验证: <30 秒
-   查询验证结果: <1 秒

✅ **安全验收**:

-   通过 3+次独立安全审计
-   zkTLS 证明不可伪造
-   数据提供者质押机制防止恶意行为

---

## 3.4 Escrow Vault (抵押与保险池)

### 3.4.1 模块概述

**核心职责**: 存放用户抵押资产,内置保险池,支持抵押借贷

**核心功能**:

-   ✅ 抵押资产管理: 用户抵押 XRWA 代币或其他资产
-   ✅ 保险池: 内置保险池,覆盖资产损失风险
-   ✅ 抵押借贷: 用户抵押资产借出 HUSD 稳定币
-   ✅ 抵押率监控: 实时监控抵押率,触发清算引擎
-   ✅ 多资产支持: 支持 XRWA、ABLE、ETH 等多种资产抵押
-   ✅ 跨链合规验证

### 3.4.2 核心合约

#### CrossChainBridge (跨链桥)

**职责**: 实现跨链资产桥接

**核心接口**:

```solidity
interface ICrossChainBridge {
    // 锁定资产并桥接到目标链
    function bridgeAsset(
        address token,
        uint256 amount,
        uint256 targetChainId,
        address recipient
    ) external;

    // 从目标链接收资产
    function receiveAsset(
        address token,
        uint256 amount,
        address recipient,
        bytes memory proof
    ) external;

    // 获取桥接记录
    function getBridgeRecord(bytes32 bridgeId) external view returns (BridgeRecord memory);
}

struct BridgeRecord {
    address token;
    uint256 amount;
    uint256 sourceChainId;
    uint256 targetChainId;
    address sender;
    address recipient;
    uint256 timestamp;
    bool completed;
}
```

**实现示例**:

```solidity
contract CrossChainBridge is ICrossChainBridge {
    mapping(bytes32 => BridgeRecord) public bridgeRecords;
    mapping(address => uint256) public lockedAssets;

    event AssetBridged(
        bytes32 indexed bridgeId,
        address indexed token,
        uint256 amount,
        uint256 targetChainId,
        address recipient
    );

    event AssetReceived(
        bytes32 indexed bridgeId,
        address indexed token,
        uint256 amount,
        address recipient
    );

    function bridgeAsset(
        address token,
        uint256 amount,
        uint256 targetChainId,
        address recipient
    ) external override {
        // 1. 验证合规
        require(
            complianceModule.canTransfer(msg.sender, address(this), amount),
            "Compliance check failed"
        );

        // 2. 锁定资产
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        lockedAssets[token] += amount;

        // 3. 生成桥接ID
        bytes32 bridgeId = keccak256(
            abi.encodePacked(token, amount, targetChainId, recipient, block.timestamp)
        );

        // 4. 记录桥接
        bridgeRecords[bridgeId] = BridgeRecord({
            token: token,
            amount: amount,
            sourceChainId: block.chainid,
            targetChainId: targetChainId,
            sender: msg.sender,
            recipient: recipient,
            timestamp: block.timestamp,
            completed: false
        });

        // 5. 触发事件 (由跨链中继器监听)
        emit AssetBridged(bridgeId, token, amount, targetChainId, recipient);
    }

    function receiveAsset(
        address token,
        uint256 amount,
        address recipient,
        bytes memory proof
    ) external override {
        // 1. 验证跨链证明
        require(verifyBridgeProof(proof), "Invalid bridge proof");

        // 2. 验证合规
        require(
            complianceModule.canTransfer(address(this), recipient, amount),
            "Compliance check failed"
        );

        // 3. 解锁资产
        require(lockedAssets[token] >= amount, "Insufficient locked assets");
        lockedAssets[token] -= amount;

        // 4. 转账给接收方
        IERC20(token).transfer(recipient, amount);

        // 5. 生成桥接ID
        bytes32 bridgeId = keccak256(proof);

        // 6. 更新桥接记录
        bridgeRecords[bridgeId].completed = true;

        // 7. 触发事件
        emit AssetReceived(bridgeId, token, amount, recipient);
    }

    function getBridgeRecord(bytes32 bridgeId) external view override returns (BridgeRecord memory) {
        return bridgeRecords[bridgeId];
    }

    // 验证跨链证明 (简化版)
    function verifyBridgeProof(bytes memory proof) internal pure returns (bool) {
        // 实际实现需要使用Axelar或LayerZero的验证逻辑
        return proof.length > 0;
    }
}
```

### 3.4.3 验收标准

✅ **功能验收**:

-   支持至少 3 条目标链 (Ethereum, BSC, Polygon)
-   支持跨链资产桥接和消息传递
-   支持跨链合规验证

✅ **性能验收**:

-   跨链桥接: <5 分钟
-   跨链消息传递: <2 分钟

✅ **安全验收**:

-   通过 3+次独立安全审计
-   跨链证明不可伪造
-   资产锁定机制防止双花

---

## 3.5 Distributor (分红系统)

### 3.5.1 模块概述

**核心职责**: 根据收益快照自动分红,支持跨资产分红 (HUSD → 投资人)

**核心功能**:

-   ✅ 收益快照: 定期对资产收益进行快照
-   ✅ 自动分红: 根据快照自动分红给 XRWA 代币持有者
-   ✅ 跨资产分红: 支持 HUSD 稳定币分红给 XRWA 持有者
-   ✅ 分红历史: 记录所有分红历史
-   ✅ 分红提取: 投资者可随时提取分红
-   ✅ NAV 计算

### 3.5.2 核心合约

#### PoolFactory (池工厂)

**职责**: 创建和管理投资池

**核心接口**:

```solidity
interface IPoolFactory {
    // 创建投资池
    function createPool(
        string memory name,
        address[] memory assets,
        TrancheConfig[] memory tranches
    ) external returns (address pool);

    // 获取投资池
    function getPool(bytes32 poolId) external view returns (address);

    // 获取所有投资池
    function getAllPools() external view returns (address[] memory);
}

struct TrancheConfig {
    string name;           // 分片名称: "Senior", "Junior"
    uint256 targetAPY;     // 目标年化收益率 (basis points)
    uint256 minInvestment; // 最小投资额
    uint256 maxInvestment; // 最大投资额
}
```

### 3.5.3 验收标准

✅ **功能验收**:

-   支持至少 2 层分片 (Senior, Junior)
-   支持投资、赎回、收益分配
-   支持 NAV 自动计算

✅ **性能验收**:

-   投资: <10 秒
-   赎回: <10 秒
-   NAV 计算: <5 秒

✅ **安全验收**:

-   通过 3+次独立安全审计
-   收益分配算法准确无误
-   防止重入攻击

---

## 3.6 Liquidation Engine (清算引擎)

### 3.6.1 模块概述

**核心职责**: 抵押率超限自动清算,拍卖抵押品

**核心功能**:

-   ✅ 抵押率监控: 实时监控所有抵押资产的抵押率
-   ✅ 自动清算: 抵押率低于阈值时自动触发清算
-   ✅ 拍卖机制: 拍卖抵押品,偿还债务
-   ✅ 清算奖励: 清算人获得清算奖励
-   ✅ 债务偿还: 优先偿还债务,剩余资产返还用户
-   ✅ Gas 代付

### 3.6.2 核心合约

#### SmartWallet (智能钱包)

**职责**: 提供智能合约钱包功能

**核心接口**:

```solidity
interface ISmartWallet {
    // 执行交易
    function execute(
        address to,
        uint256 value,
        bytes memory data
    ) external returns (bytes memory);

    // 批量执行交易
    function executeBatch(
        address[] memory to,
        uint256[] memory value,
        bytes[] memory data
    ) external returns (bytes[] memory);

    // 添加恢复地址
    function addRecoveryAddress(address recovery) external;

    // 恢复钱包
    function recoverWallet(address newOwner) external;

    // 获取所有者
    function getOwner() external view returns (address);
}
```

### 3.6.3 验收标准

✅ **功能验收**:

-   支持智能合约钱包
-   支持社交恢复 (至少 2 个恢复地址)
-   支持批量交易

✅ **性能验收**:

-   执行交易: <5 秒
-   批量执行: <10 秒

✅ **安全验收**:

-   通过 3+次独立安全审计
-   防止重入攻击
-   社交恢复机制安全可靠

---

## 3.7 FeePool (费用池)

### 3.7.1 模块概述

**核心职责**: 所有 Gas 与手续费进入 FeePool,按 6 层分配

**核心功能**:

-   ✅ 费用收集: 收集所有 Gas 费用和手续费
-   ✅ 6 层分配:
-   35%回购销毁 ABLE
-   15%分红给 veABLE 持有者
-   20%研发与运维
-   15%合规与法律储备
-   10%节点激励
-   5%生态基金
-   ✅ 自动分配: 每个区块自动执行分配
-   ✅ 分配历史: 记录所有分配历史

### 3.7.2 验收标准

✅ **功能验收**:

-   支持 DEX 交易 (Uniswap V3 兼容)
-   支持借贷协议 (Aave 兼容)
-   支持质押挖矿

✅ **性能验收**:

-   DEX 交易: <5 秒
-   借贷操作: <10 秒

---

**文档完成**

**上一章节**: [004-2]技术架构.md
**下一章节**: [004-4]技术规格.md
**返回主索引**: [004]USDable Chain 开发需求文档-主索引.md

**版权声明**: 本文档仅供内部使用,未经授权不得外传。
